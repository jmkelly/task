@page
@using Task.Api.Pages
@model IndexModel
@{
    ViewData["Title"] = "Kanban Board";
}

<!-- Hero-style header with gradient background -->
<section class="hero-section">
    <div class="hero-container">
        <div class="hero-content">
            <h1><span class="emoji emoji-leading">ğŸš€</span>Task Board</h1>
            <p class="header-subtitle">Manage your workflow with drag-and-drop simplicity</p>
        </div>
        <div class="hero-actions">
            <button class="btn-primary" hx-get="/Index?handler=CreateModal" hx-target="body" hx-swap="beforeend">
                <span class="emoji emoji-leading">â•</span>Add Task
            </button>
            <button class="btn-secondary" hx-post="/Index?handler=ClearBoard" hx-include="#filter-form" hx-target="#board-container" hx-swap="outerHTML" onclick="return confirm('Are you sure you want to clear all tasks? This action cannot be undone.')">
                <span class="emoji emoji-leading">ğŸ—‘ï¸</span>Clear Board
            </button>
        </div>
    </div>
</section>

@await Html.PartialAsync("_BoardContainer", Model)

<!-- Modal container for task creation -->
<div id="modal-container"></div>

@Html.AntiForgeryToken()

@section Scripts {
    <script>
        document.addEventListener('htmx:configRequest', function(evt) {
            const token = document.querySelector('input[name="__RequestVerificationToken"]');
            if (token) {
                evt.detail.headers['RequestVerificationToken'] = token.value;
            }
        });

        let draggedElement = null;

        function handleDragStart(event) {
            draggedElement = event.target;
            event.target.classList.add('dragging');
            event.dataTransfer.setData('text/plain', event.target.dataset.uid);
        }

        function handleDrop(event) {
            event.preventDefault();
            const uid = event.dataTransfer.getData('text/plain');
            const status = event.currentTarget.closest('.kanban-column').dataset.status;

            if (uid && status && draggedElement) {
                // Remove dragging class
                draggedElement.classList.remove('dragging');

                // We must include the filter form values when updating status
                const formData = new FormData(document.getElementById('filter-form'));
                formData.append('uid', uid);
                formData.append('status', status);

                // Send HTMX request
                htmx.ajax('POST', '/Index?handler=UpdateStatus', {
                    values: Object.fromEntries(formData),
                    target: '#board-container',
                    swap: 'outerHTML'
                });
            }
        }

        function updateFilterToggleState(toggleButton, advancedFilters, shouldExpand) {
            const isExpanded = shouldExpand ?? toggleButton.getAttribute('aria-expanded') === 'true';
            const nextState = !isExpanded;
            toggleButton.setAttribute('aria-expanded', String(nextState));
            advancedFilters.classList.toggle('is-visible', nextState);
        }

        function setupFilterToggle() {
            const toggleButton = document.querySelector('[data-filter-toggle]');
            const advancedFilters = document.querySelector('[data-filter-advanced]');

            if (!toggleButton || !advancedFilters) {
                return;
            }

            toggleButton.addEventListener('click', function() {
                updateFilterToggleState(toggleButton, advancedFilters);
            });

            const mobileQuery = window.matchMedia('(max-width: 768px)');
            function handleMediaChange(event) {
                if (!event.matches) {
                    toggleButton.setAttribute('aria-expanded', 'true');
                    advancedFilters.classList.add('is-visible');
                    return;
                }

                toggleButton.setAttribute('aria-expanded', 'false');
                advancedFilters.classList.remove('is-visible');
            }

            handleMediaChange(mobileQuery);
            if (typeof mobileQuery.addEventListener === 'function') {
                mobileQuery.addEventListener('change', handleMediaChange);
            } else if (typeof mobileQuery.addListener === 'function') {
                mobileQuery.addListener(handleMediaChange);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            setupFilterToggle();

            // Add drag over effects
            document.addEventListener('dragover', function(e) {
                e.preventDefault();
                const column = e.target.closest('.kanban-column');
                if (column) {
                    column.classList.add('drag-over');
                }
            });

            document.addEventListener('dragleave', function(e) {
                const column = e.target.closest('.kanban-column');
                if (column && !column.contains(e.relatedTarget)) {
                    column.classList.remove('drag-over');
                }
            });

            document.addEventListener('drop', function(e) {
                // Remove all drag-over classes
                document.querySelectorAll('.kanban-column').forEach(col => {
                    col.classList.remove('drag-over');
                });
            });

            // Clean up on drag end
            document.addEventListener('dragend', function(e) {
                document.querySelectorAll('.dragging').forEach(el => {
                    el.classList.remove('dragging');
                });
                document.querySelectorAll('.kanban-column').forEach(col => {
                    col.classList.remove('drag-over');
                });
            });
        });
    </script>
}
